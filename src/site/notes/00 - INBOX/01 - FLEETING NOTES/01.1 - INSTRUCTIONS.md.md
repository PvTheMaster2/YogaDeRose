---
created: 2025-04-17T23:54
updated: 2025-04-18T03:26
dg-publish: true
---

from pathlib import Path
import re

# Caminho do arquivo LaTeX convertido em markdown (mas ainda com comandos LaTeX)
latex_md_path = Path("/mnt/data/Yoga_R00.md")
output_path = Path("/mnt/data/Yoga_R00_cleaned.md")

# Leitura do conte√∫do original
with open(latex_md_path, encoding="utf-8") as f:
    raw_text = f.read()

# Fun√ß√µes para limpar e converter LaTeX -> Markdown
def convert_latex_to_markdown(text):
    # Remove comandos de formata√ß√£o LaTeX comuns
    text = re.sub(r"\\textbf\{([^}]+)\}", r"**\1**", text)
    text = re.sub(r"\\textit\{([^}]+)\}", r"_\1_", text)
    text = re.sub(r"\\underline\{([^}]+)\}", r"<u>\1</u>", text)
    text = re.sub(r"\\section\*?\{([^}]+)\}", r"# \1", text)
    text = re.sub(r"\\subsection\*?\{([^}]+)\}", r"## \1", text)
    text = re.sub(r"\\subsubsection\*?\{([^}]+)\}", r"### \1", text)
    text = re.sub(r"\\begin\{itemize\}", "", text)
    text = re.sub(r"\\end\{itemize\}", "", text)
    text = re.sub(r"\\item", r"-", text)
    text = re.sub(r"\\begin\{center\}", "", text)
    text = re.sub(r"\\end\{center\}", "", text)
    text = re.sub(r"\\newline", r"\n", text)
    text = re.sub(r"\\%", "%", text)
    text = re.sub(r"~", " ", text)
    text = re.sub(r"\\[a-zA-Z]+\*?(?:\[[^\|^]]*\])?(?:\{[^}]*\})*", "", text)  # remove outros comandos gen√©ricos
    text = re.sub(r"\n{3,}", "\n\n", text)  # limita espa√ßamento excessivo
    return text.strip()

# Aplicar a convers√£o
cleaned_text = convert_latex_to_markdown(raw_text)

# Salvar resultado
with open(output_path, "w", encoding="utf-8") as f:
    f.write(cleaned_text)

# Visualizar trecho inicial da convers√£o
cleaned_text[:2000]


Perfeito, Pedro!

A primeira etapa de convers√£o do conte√∫do do seu arquivo `Yoga_R00.md` foi conclu√≠da com sucesso! Agora temos um texto com:

- ‚úÖ Comandos LaTeX convertidos para Markdown (`\section`, `\textbf`, `\item`, etc.)
    
- ‚úÖ Hierarquias reconhec√≠veis com `#` e `##`
    
- ‚úÖ Listas convertidas com `-`
    
- ‚úÖ Blocos limpos de comandos inutilizados
    

Esse novo arquivo se chama **`Yoga_R00_cleaned.md`**, e agora pode ser usado como base para:

---

## üöÄ Etapas Imediatas Sugeridas

### ‚úÖ Pr√≥xima Etapa: Parse Markdown para Zettels

Agora que o texto est√° limpo e com estrutura Markdown padr√£o, posso:

1. **Rodar o script de parser e split** para gerar os arquivos `.md` com frontmatter (Zettels);
    
2. Exibir os arquivos criados com seus t√≠tulos e caminhos;
    
3. Iniciar a cria√ß√£o da CLI interativa, flashcards ou dashboard com base nisso.
    

Deseja que eu execute o passo 1 agora e converta o novo Markdown em seus primeiros Zettels com YAML completo? ‚Äã‚Äã

##### Voc√™ disse:

vamos ver, pode seguir

foi entrao criado os zeetls com as 69 sections do livro

![[Pasted image 20250417235648.png\|Pasted image 20250417235648.png]]![[Pasted image 20250417235657.png\|Pasted image 20250417235657.png]]


Aqui est√£o os primeiros **Zettels gerados** a partir do conte√∫do limpo do `Yoga_R00.md`:

- Cada se√ß√£o do documento virou um arquivo `.md` com:
    
    - ‚úÖ T√≠tulo convertido
        
    - ‚úÖ Corpo do texto preservado
        
    - ‚úÖ YAML frontmatter com metadados padr√£o Zettelkasten
        

Agora que a base est√° pronta, posso seguir com os pr√≥ximos elementos prometidos:

1. üìÑ Criar o **template Templater / QuickAdd** para cria√ß√£o manual ou autom√°tica de novas notas no mesmo padr√£o.
    
2. üìã Criar uma **nota de controle de projeto** (Project Note) para seu Obsidian.
    
3. üóÇÔ∏è Criar a **estrutura padr√£o de pastas do Vault**, com pastas e instru√ß√µes b√°sicas embutidas.
    

Quer que eu execute o item 1 agora? ‚Äã‚Äã

##### Voc√™ disse:

sim, estamos indo bem, prossiga



import os
import re
from pathlib import Path
from datetime import datetime
import unicodedata
import argparse

# === CONFIGURA√á√ïES GLOBAIS ===
INPUT_FILE = "Yoga_R00.md"  # Markdown vindo do LaTeX
OUTPUT_DIR = "Zettels"

# === FUN√á√ïES AUXILIARES ===
def slugify(text):
    text = unicodedata.normalize('NFKD', text).encode('ascii', 'ignore').decode('ascii')
    text = re.sub(r'[^\w\s-]', '', text.lower())
    return re.sub(r'[-\s]+', '-', text).strip('-_')

def gerar_frontmatter(titulo, data=None, tags=None):
    data = data or datetime.now().strftime('%Y-%m-%d')
    slug = slugify(titulo)
    id_str = datetime.now().strftime('%Y%m%dT%H%M%S')
    tags_yaml = ', '.join(tags or [])
    return f"""---
id: {id_str}
title: {titulo}
tags: [{tags_yaml}]
template_type: Literature
source: Trato de Y√¥ga do Mestre De Rose
created: {data}
---\n"""

def dividir_por_secao(md_text):
    padrao = re.compile(r"^\\s*(\\\d{1,2}(?:\\.\\d{1,2})*)\\s+(.*?)$", re.MULTILINE)
    secoes = []
    posicoes = list(padrao.finditer(md_text))

    for i, match in enumerate(posicoes):
        inicio = match.end()
        fim = posicoes[i + 1].start() if i + 1 < len(posicoes) else len(md_text)
        titulo = match.group(2).strip()
        conteudo = md_text[inicio:fim].strip()
        secoes.append((titulo, conteudo))

    return secoes

def salvar_notas(secoes):
    Path(OUTPUT_DIR).mkdir(exist_ok=True)
    for titulo, conteudo in secoes:
        nome_arquivo = f"{slugify(titulo)}.md"
        frontmatter = gerar_frontmatter(titulo, tags=["type/literature", "source/book", "theme/yoga"])
        with open(Path(OUTPUT_DIR) / nome_arquivo, 'w', encoding='utf-8') as f:
            f.write(frontmatter + '\n' + conteudo.strip() + '\n')

def processar_arquivo():
    with open(INPUT_FILE, encoding='utf-8') as f:
        md_text = f.read()
    secoes = dividir_por_secao(md_text)
    salvar_notas(secoes)
    print(f"‚úÖ {len(secoes)} se√ß√µes exportadas para a pasta '{OUTPUT_DIR}' com sucesso.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Dividir arquivo .md estruturado por LaTeX e salvar como Zettels com frontmatter.")
    parser.add_argument("--input", type=str, help="Arquivo de entrada .md", default=INPUT_FILE)
    parser.add_argument("--output", type=str, help="Diret√≥rio de sa√≠da", default=OUTPUT_DIR)
    args = parser.parse_args()

    if args.input:
        global INPUT_FILE
        INPUT_FILE = args.input
    if args.output:
        global OUTPUT_DIR
        OUTPUT_DIR = args.output

    processar_arquivo()



‚úÖ Pronto, Pedro! Aqui est√° o script Python-base criado diretamente no canvas ‚Äî **Yoga Split Script** ‚Äî que:

- **L√™** o conte√∫do do `Yoga_R00.md`;
    
- **Detecta** se√ß√µes formatadas com padr√£o LaTeX numerado (`1`, `1.1`, `2.3.4`...);
    
- **Converte** cada se√ß√£o em uma nota individual `.md`;
    
- **Aplica** um **frontmatter robusto** com metadados compat√≠veis com seu sistema Obsidian Zettelkasten;
    
- **Organiza** tudo na pasta `Zettels/`.
    

---

### ‚úçÔ∏è Pr√≥ximos Passos Recomendados

1. **Teste local**:
    
    - Copie o `Yoga_R00.md` para o diret√≥rio do script.
        
    - Execute com:
        
        bash
        
        CopiarEditar
        
        `python YogaSplitScript.py`